// Generated by gencpp from file lslidar_cx_driver/LslidarPacket.msg
// DO NOT EDIT!

#ifndef LSLIDAR_CX_DRIVER_MESSAGE_LSLIDARPACKET_H
#define LSLIDAR_CX_DRIVER_MESSAGE_LSLIDARPACKET_H


#include <string>
#include <vector>
#include <memory>
#include <boost/array.hpp>
#include <boost/shared_ptr.hpp>

namespace lslidar_cx_driver
{
template <class ContainerAllocator>
struct LslidarPacket_
{
  typedef LslidarPacket_<ContainerAllocator> Type;

  LslidarPacket_()
    : stamp()
    , data()  {
      //printf("LslidarPacket_()\n");
      data.assign(0);
  }
  LslidarPacket_(const ContainerAllocator& _alloc)
    : stamp()
    , data()  {
  (void)_alloc;
      data.assign(0);
  }

  Stamp stamp;
  typedef boost::array<uint8_t, 1212>  _data_type;
  _data_type data;





  typedef boost::shared_ptr< ::lslidar_cx_driver::LslidarPacket_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::lslidar_cx_driver::LslidarPacket_<ContainerAllocator> const> ConstPtr;

}; // struct LslidarPacket_

typedef ::lslidar_cx_driver::LslidarPacket_<std::allocator<void> > LslidarPacket;

typedef boost::shared_ptr< ::lslidar_cx_driver::LslidarPacket > LslidarPacketPtr;
typedef boost::shared_ptr< ::lslidar_cx_driver::LslidarPacket const> LslidarPacketConstPtr;

// constants requiring out of line definition


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::lslidar_cx_driver::LslidarPacket_<ContainerAllocator1> & lhs, const ::lslidar_cx_driver::LslidarPacket_<ContainerAllocator2> & rhs)
{
  return lhs.stamp == rhs.stamp &&
    lhs.data == rhs.data;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::lslidar_cx_driver::LslidarPacket_<ContainerAllocator1> & lhs, const ::lslidar_cx_driver::LslidarPacket_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace lslidar_cx_driver


namespace ros
{
namespace serialization
{

  /* template<class ContainerAllocator>
  struct Serializer
  {
    // 序列化函数
    template<typename Stream>
    static void serialize(Stream& stream, const lslidar_cx_driver::LslidarPacket_<ContainerAllocator>& packet)
    {
      // 序列化 Stamp 对象
      std::vector<unsigned char> stamp_vector = packet.stamp.to_vector();
      size_t stamp_size = stamp_vector.size();
      stream.write(reinterpret_cast<const char*>(&stamp_size), sizeof(stamp_size));
      stream.write(reinterpret_cast<const char*>(stamp_vector.data()), stamp_size);

      // 序列化 data 数组
      stream.write(reinterpret_cast<const char*>(packet.data.data()), packet.data.size());
    }

    // 反序列化函数
    template<typename Stream>
    static void deserialize(Stream& stream, lslidar_cx_driver::LslidarPacket_<ContainerAllocator>& packet)
    {
      // 反序列化 Stamp 对象
      size_t stamp_size;
      stream.read(reinterpret_cast<char*>(&stamp_size), sizeof(stamp_size));
      std::vector<unsigned char> stamp_vector(stamp_size);
      stream.read(reinterpret_cast<char*>(stamp_vector.data()), stamp_size);
      packet.stamp = Stamp::from_vector(stamp_vector);

      // 反序列化 data 数组
      stream.read(reinterpret_cast<char*>(packet.data.data()), packet.data.size());
    }
  }; */

} // namespace serialization
} // namespace ros


#endif // LSLIDAR_CX_DRIVER_MESSAGE_LSLIDARPACKET_H
